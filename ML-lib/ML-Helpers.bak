#lang racket
(require racket/format (for-syntax racket/format)
         (for-meta 2 syntax/parse)
         (for-meta 2 racket)
         "../ML-lib/Parser/FastParser.rkt")
(require (for-syntax syntax/parse))
(require (for-syntax racket/provide-transform))
(require (for-syntax (only-in racket drop)))
(require racket/provide)

(provide ~my-s
         ~my-a
         catch-error-as-symbol
         setup-printer
         check-contract
         unprefix-out
         #%arity-app
         (for-syntax unbound
                     to-syntax-rules
                     unhygienic)
         display-compile-time-error
         make-shared-variable
         setup-reader
         setup-all-reader
         fill-tank
         check-decrement-fuel increment-fuel fuel
         transform-bad-compile-errors
         student-print
         (struct-out ml-struct)
         (struct-out ml-object)
         )

;Determines when functions
;should time out. Calls check-decrement at various points
;on each function call to lose fuel.
(define fuel 750)
(define (fill-tank) (set! fuel 750))
(define (check-decrement-fuel)
  (begin
    (if (<= fuel 0) (raise-user-error "Program timed out") (set! fuel (- fuel 1)))))
(define (increment-fuel)
  (set! fuel (+ fuel 1)))




;;PRINTER UTILITIES
;Determines how to print things like numbers and lists
;sets the global printer handler to use these settings

(define (student-print to-print)
  (define stringified "")
  (parameterize ([current-output-port (open-output-string)])
    (print to-print)
    (set! stringified (get-output-string (current-output-port))))
  (display stringified)
  (display #\newline)
  to-print)
(set! student-print (procedure-rename student-print 'print))

;; Template for a struct INSTANCE
(struct ml-struct (name get-func set-func vals id))
;; Template for object
(struct ml-object (name get-func set-func exists-func parent id))
;; vals and name are just for printing. get-func takes the name of the element you want and returns it's value


;Takes a number and chops any digits past
;the -10'th power off. Allows numbers like
;9001.001 which, when inexact is really something like
;9001.0010... to get correctly displayed
(define (chop-lower num)
  (/ (round (* num #e1e10)) #e1e10))

;Only works on positive decimals
;send in inexacts as exact so the * 10 doesn't mess
;with their value
;Converts a number to scientific notation
(define (to-sci num exact?)
  (define (helper inner-num place)
    (let ([next-num (* 10 inner-num)])
      (if (>= (* (sgn next-num) next-num) 1)
          (~a
            (num->decimal-string next-num)
           "e"
           place)
          (helper next-num (- place 1)))))
  (helper num -1))


(define (standard-print-num num place)
  ;standard way to round to a certain decimal place.
  ;then we make it a decimal string, chop of trailing 0's and trail of the decimal point. Note, this doesn't work for
  ; 0 (it would chop of the 0 as a trailing 0) so we make a special case.
  (if (= num 0) "0"
  (let ()
  (define formatted (real->decimal-string (/ (round (* (inexact->exact num) (expt 10 place))) (expt 10 place)) 10))
  (string-trim  (string-trim formatted "0" #:left? #f #:repeat? #t) "." #:left? #f))))
  ;Takes a number and determines how to print it
;Stop is how many decimal places to print decimal numbers to
(define (num->decimal-string num)
  ;Takes in a number and converts it to a decimal form
  (if
    ;If very small, we'd like to print it in scientific notation
   (and (not (= 0 num)) (<= num #e1e-7) (>= num #e-1e-7))
   (to-sci (if (exact? num) num (inexact->exact num)) (exact? num))
   ;else we chop it to 10 decimal places, round it off, and print.
   (standard-print-num num 10)))

;Prints lists
(define (list-to-string list depth)
  (define (fold-function x acc)
    (cond
      [(null? acc)
       (string->list (~my-s x #:depth (+ 1 depth)))]
      [(cons? acc)
       (append acc (string->list (~a #\, #\space (~my-s x #:depth (+ 1 depth)))))]))
  (let ([inner-list (foldl fold-function '() list)])
    (string-append "[list: " (list->string inner-list) "]")))

;Prints vectors
(define (vector-to-string vec depth)
  (define (fold-function x acc)
    (cond
      [(null? acc)
       (string->list (~my-s x #:depth (+ 1 depth)))]
      [(cons? acc)
       (append acc (string->list (~a #\, #\space (~my-s x #:depth (+ 1 depth)))))]))
  (let ([inner-list (foldl fold-function '() (vector->list vec))])
    (string-append "[array: " (list->string inner-list) "]")))

(define (struct-to-string s depth)
  (define (fields-to-str l)
    (if (empty? l)
        ""
        (string-append " " (~my-s (car l) #:depth (+ 1 depth)) (fields-to-str (cdr l)))))
  (string-append (format "[~s:" (ml-struct-name s)) (fields-to-str (ml-struct-vals s)) "]"))
(define (object-to-string o)
  (format "[~s]" (ml-object-name o)))

;Determines the printed representation of an object.
(define (~my-s obj #:depth [depth 0])
  (cond
    [(> depth 5) "..."]
    [(number? obj)
     (cond
       [(infinite? obj) (if (= (sgn obj) 1) "Inf" "-Inf")]
       [(nan? obj) "NaN"]
       [(real? obj) (num->decimal-string obj)]
       [else (number->string obj)])] ;shouldn't ever be called.
    [(boolean? obj) (if obj "true" "false")]
    ;Will eventually want to print as #<procedure:proc-name>
    [(procedure? obj) "#<procedure>"]
    [(list? obj) (list-to-string obj depth)]
    [(symbol? obj) (~a obj)]
    [(vector? obj) (vector-to-string obj depth)]
    ;(struct ml-struct (name f vals))
    [(ml-struct? obj)(struct-to-string obj depth)]
    [(ml-object? obj) (object-to-string obj)]
    [else (~s obj)
          ]))

;Rarely necessary to deal with escaped characters
;that ~my-s adds to things like strings.
(define (~my-a obj)
  (if (or (string? obj) (symbol? obj)) (~a obj)
      (~my-s obj)))

;Sets the printer to use the print settings above
;if placed inside module-begin, likely doesn't need to be unhygienic
(define-syntax (setup-printer stx)
  (syntax-case stx ()
    [_ (datum->syntax stx '(global-port-print-handler (lambda (a b) (write-string (~my-s a) b))) stx)]))


;;CONTRACTS

;Checks the contract for a specific value. Prints an error message
;if it fails.
(define-syntax-rule (check name arg condition cond-name arg-num)
  (if (condition arg) (values)
      (raise-user-error (~a name " expected " cond-name " for argument " arg-num ". Received " (~my-s arg) "."))))

;Checks an entire contract by checking the contracts on each value
(define-syntax-rule (check-contract name (arg ...) (condition ...) (cond-name ...))
  (let ([arg-num 1])
    (let ([enforce (lambda (ar con con-name) (check name ar con con-name arg-num))])
      (begin (enforce arg condition cond-name) (set! arg-num (+ arg-num 1))) ...)))

;;Unprefix-out
;A provide macro that makes life easier when importing and exporting MLs

;Drops the number of characters in the given id from each item
;imported from the given file, then exports them
(define-syntax unprefix-out
  (make-provide-pre-transformer
   (lambda (stx modes)
     (syntax-parse stx
       [(_ id module-path)
        (pre-expand-export
         #'(filtered-out
            (lambda (id-string)
              (list->string (drop (string->list id-string)
                                  (string-length (symbol->string 'id)))))
            (all-from-out module-path)) modes)]))))

;;#%APP OVERRIDE
;;Making an #%app with custom error messages

;Gets the name of an object.
(define (name obj)
  (if (object-name obj) (object-name obj) (~my-a obj)))

;#%app, but gives clean errors when you try to apply a non
;procedure, or when you apply a procedure to the wrong number
;of arguments

;If object has an object-name, then it will be used when printing
;otherwise, it will print as normal with the printer above
(define-syntax-rule (#%arity-app proc args ...)
  (let ([ex-proc proc] [eval-args (list args ...)])
    (if (procedure? ex-proc)
        (let ([arity (procedure-arity ex-proc)]
              [given (length eval-args)])
          (if (arity-includes? arity given)
              (apply ex-proc eval-args)
              (raise-user-error (~a (name ex-proc) ": expected " arity " arguments. Given " given "."))))
        (raise-user-error
         (~a "Attempted to apply " (name ex-proc) ", but it is not a procedure.")))))

;Default syntax-transformer binding
(begin-for-syntax
  (define-syntax (unbound stx)
    (syntax-parse stx
      [_ #'(... (syntax-rules () [(_ stx ...) (error "Unbound syntax parameter")]))]))
  (define-syntax (to-syntax-rules stx)
    (syntax-parse stx
      [(_ parameterize-to) #'(... (syntax-rules () [(_ stx ...) (parameterize-to stx ...)]))])))


;For making shared-variables in a language set.
;Makes a variable with a certain number of arguments
;bound to an error

;Makes a setter that allows it to be set by the languages
;Essentially a parameter, but there is no splicing-parameterize
;so this is used instead.

;EDIT: Now that we're not splicing/only displaying one answer,
;these mostly should become parameters. The exception is the function
;in fields that is called in the printer function for records. That one
; needs to be a shared variable or the printing will happen outside the
;scope of the parameterization
(define-syntax (make-shared-variable stx)
  (syntax-parse stx
    [(_ var-name args ...)
     (with-syntax ([setter-name
                    (string->symbol (~a
                                     (syntax->datum #'var-name)
                                     "-setter"))])
       (datum->syntax stx
                      (syntax->datum
                       #'(begin
                           (define (var-name args ...)
                             (error (~a "Unbound shared variable: " 'var-name)))
                           (define (setter-name new-val) (set! var-name new-val))))))]))


;This doesn't work in other modules?? Odd
(define-for-syntax (unhygienic stx)
  (datum->syntax stx (syntax->datum stx)))

;; Macros to make all the main.rkt files easier to manage
(define-syntax (setup-reader stx)
  (syntax-parse stx
    [(_ language-name defined-in-lang ...)
     (with-syntax ([(defined ...)
                    (foldr (lambda (x acc)
                             (cons x (cons #t acc)))
                           '()
                           (syntax->list #'(defined-in-lang ...)))])
       (unhygienic #`(module reader racket
                       (require
                         "../ML-lib/Parser/FastParser.rkt"
                         ;"../ML-lib/Parser/getInfo.rkt"
                         syntax/strip-context
                         syntax/module-reader)
                       (provide (rename-out [ML-read-syntax read-syntax]
                                            [ML-read read])
                               ; get-info
                                )
                       (define (ML-read-syntax _ in)  (strip-context
                                                       (with-syntax ([src (if (symbol? (object-name in)) (object-name in) 'required-in)])
                                                         #`(module src language-name #,@(ML-parse (object-name in) in 'language-name
                                                                                                  defined ...)))))
                       (define (ML-read in) (syntax->datum (ML-read-syntax #f in))))))]))



;Ugly. Towards the top of the list of things that should be cleaned.
(define-syntax (setup-all-reader stx)
  (syntax-parse stx
    [(_ (languages ...) (display-names ...) constructs ...)
     (with-syntax ([(defined ...)
                    (foldr (lambda (x acc)
                             (cons x (cons #t acc)))
                           '()
                           (syntax->list #'(constructs ...)))]
                   [(languageNums ...) (build-list (length (syntax->list #'(languages ...))) (lambda (x) (string->symbol (~a (+ 1 x)))))]
                   [languageSymbol (car (syntax->list #'(languages ...)))])

       (unhygienic #`(module reader racket
                       (require    "../ML-lib/Parser/FastParser.rkt"
                                   "../ML-lib/Parser/getInfo.rkt"
                                   "../version.rkt"
                                   syntax/strip-context)
                       (provide (rename-out [ML-read-syntax read-syntax]
                                            [ML-read read])
                                get-info)

                       (define (ML-read-syntax _ in)
                         (with-syntax ([(... (modules ...)) (ML-parse (object-name in) in 'languageSymbol "dummyName"
                                                                      defined ... #:runAll (syntax->list #'(languages ...)))])
                           (strip-context #`(module runAll racket
                                                              (define (compile-error->string mes err)
                                                                (if (exn:fail:syntax? err)
                                                                    (let ([expr-list (exn:fail:syntax-exprs err)])
                                                                      (if (= (length expr-list) 1)
                                                                          (cond
                                                                            [(string-contains? mes "set!")
                                                                             (~a "Unbound identifier: " (syntax->datum (car expr-list)))]

                                                                            [(string-contains? mes "duplicate argument")
                                                                             (~a "Duplicate argument names: " (syntax->datum (car expr-list)))]


                                                                            [(string-contains? mes "duplicate binding name")
                                                                             (~a "Duplicate function names: " (syntax->datum (car expr-list)))]

                                                                            [else mes])
                                                                          mes))
                                                                    mes))
                                                              (require syntax/location)#,@(... #'(modules ...))
                                                              (define prompt-tag (make-continuation-prompt-tag))
                                                              ;Catch errors. Display as symbols.
                                                              (displayln (string-append "version: " #,version-string))
                                                              (begin
                                                                (display (string-append "\n" display-names "\n"))
                                                                (call-with-continuation-prompt (lambda ()
                                                                                                 (call-with-exception-handler
                                                                                                  (lambda (x) (abort-current-continuation prompt-tag x))
                                                                                                  (lambda () (dynamic-require (quote-module-path languageNums) #f))))
                                                                                               prompt-tag (lambda (v) (string->symbol (string-append "ERROR: " (compile-error->string
                                                                                                                                                                (vector-ref (struct->vector v) 1)
                                                                                                                                                                v)"\n")))))
                                                              ...))))
                       (define (ML-read in) (syntax->datum #f (ML-read-syntax #f in))))))]))


;Sets the display handler to display
;the two syntax errors that we haven't fixed
; in ways that make it seem like we've
;fixed them
(define-syntax-rule (display-compile-time-error)
  (begin
    (define current (error-display-handler))
    (error-display-handler (display-error current))))
;The bulk of the rule above
(define (display-error current)
  (lambda (mes err)
    (if (exn:fail:syntax? err)
        (let ([expr-list (exn:fail:syntax-exprs err)])
          (if (= (length expr-list) 1)
              (cond
                [(string-contains? mes "set!")
                 (current (~a "Unbound identifier: " (syntax->datum (car expr-list)))
                          (make-exn:fail:user (~a "Unbound identifier: " (syntax->datum (car expr-list))) (exn-continuation-marks err)))]

                [(string-contains? mes "duplicate argument")
                 (current  (~a "Duplicate argument names: " (syntax->datum (car expr-list)))
                          (make-exn:fail:user (~a "Unbound identifier: " (syntax->datum (car expr-list))) (exn-continuation-marks err)))]

                [(string-contains? mes "duplicate binding name")
                 (current (~a "Duplicate function names: " (syntax->datum (car expr-list)))
                          (make-exn:fail:user (~a "Duplicate function names: " (syntax->datum (car expr-list))) (exn-continuation-marks err)))]
                [else (current mes err)])
              (current mes err)))
        (current mes err))))

;Takes a program and if it produces a runtime eror, will catch it
;and display it as a symbol
(define-syntax (catch-error-as-symbol stx)
  (syntax-parse stx
    [(_ program ...)
     #'(let ()
         (define prompt-tag (make-continuation-prompt-tag))
         (call-with-continuation-prompt
          (lambda ()
            (call-with-exception-handler
             (lambda (x) (abort-current-continuation prompt-tag x))
             (lambda () program ...)))
          prompt-tag
          (lambda (v) (string->symbol (exn-message v)))))]))
 (define (catch-compile-time err)
   (let ([mes (vector-ref (struct->vector err) 1)])
    (if (exn:fail:syntax? err)
        (let ([expr-list (exn:fail:syntax-exprs err)])
          (if (= (length expr-list) 1)
              (cond
                [(string-contains? mes "set!")
                 
                          (make-exn:fail:user (~a "Unbound identifier: " (syntax->datum (car expr-list))) (exn-continuation-marks err))]

                [(string-contains? mes "duplicate argument")
                 
                          (make-exn:fail:user (~a "Duplicate argument names: " (syntax->datum (car expr-list))) (exn-continuation-marks err))]

                [(string-contains? mes "duplicate binding name")
                          (make-exn:fail:user (~a "Duplicate function names: " (syntax->datum (car expr-list))) (exn-continuation-marks err))]
                [else err])
              err))
        err)))


(define-syntax (transform-bad-compile-errors stx)
  (syntax-parse stx
    [(_ program ...)
     #'(let ()
         (define prompt-tag (make-continuation-prompt-tag))
         (call-with-continuation-prompt
          (lambda ()
            (call-with-exception-handler
             (lambda (x) (abort-current-continuation prompt-tag x))
             (lambda () program ...)))
          prompt-tag
          (lambda (v) (raise (catch-compile-time v)))))]))

